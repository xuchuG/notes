# 第一章

# 第二章

## 2.1.程序变成可执行文件的步骤

预处理(预编译)-》编译(变成汇编代码)-》汇编(变成机器码)-》链接

预编译：gcc  -E  hello.c -o hello.i  (这个过程主要是处理源代码文件中以“#”开始的预编译指令)

编译：gcc -S hello.i -o hello.s  或 gcc -S hello.c -o hello.s(这个过程就是把预处理完的文件进行一系列词法分析、语法分析、语义分析及优化后生产相应的汇编代码文件，这是程序构建的核心部分)

汇编：gcc -c hello.s -o hello.o 或 gcc -c hello.c -o hello.o (这个过程只需要对照汇编指令和机器指令的对照表将汇编代码转变成机器可以执行的指令即可)

链接：gcc hello.o -o hello   (将生成的目标文件全部链接起来)

> 实际上gcc 这个命令是预编译编译程序cc1,汇编as，链接器ld这些程序的包装，gcc会根据不同的采纳数要求去调用这些程序

## 2.2链接器的功能

把一些指令对其他符号的引用加以修正，实际上跟“纸带程序，程序员人工调整地址一样”

## 2.3符号表的作用

保存函数和变量的符号，为了在链接的时候进行重定位



# 第三章

## 3.1 ELF文件的格式

> 它主要包括四个部分，文件头，.text段，.data段，.bss段（当然还有其他的段）
>
> 文件头：包括描述文件的属性（是否可执行，静态链接还是动态链接），段表（描述后面各段的信息）
>
> .text段：保存编译好的机器码
>
> .data段：初始化的全局变量和局部静态变量
>
> .bss段：未初始化的全局变量和局部静态变量（ps.在这部分只是记录了未初始化变量的空间总和，只是帮这些变量预留了空间，没有实际内容不占据空间）

> 为什么有.data段了还另外需要一个.bss段?
>
> 虽然我们是知道未初始化的全局变量和局部静态变量默认值都是0，本来也是可以放在.data段的。不过正因为他们的值都是0，所以为了提高效率（节省磁盘空间），所以就集中把这些变量全放在一块了	

> 代码段（.text段）和数据段（.data段和.bss段）分开放的原因：
>
> 1、可以设置数据段可读写，代码段可读，防止进程修改代码段
>
> 2.加大cpu的cache的命中率
>
> 3.共享数据或者代码

## 3.2与链接相关的段

.systab(符号表，比较关键的字段，st_name(符号名，即它在字符串表中的下标)，st_value(一般表示函数或变量在某段的偏移量)，st_shndx(标识符号所在的段))，.rel.*(重定位表，如.rel.text,说明.text段有需要重定位的函数)

## 3.3函数签名和符号修饰

使用这两个方式来避免符号冲突（在编译器早期，符号名和相应的变量和函数名是一样的，导致了一些问题）

```c++
//源代码
int func(int);
class C{
  int func(int);
    class C2{
      int func(int);  
    };
};
namespace N{
  int func(int);  
};


```

| 函数签名             | 符号修饰         |
| -------------------- | ---------------- |
| int func(int)        | _Z4funci         |
| int C::func(int)     | _ZN1C4funcEi     |
| int C::C2::func(int) | _ZN1C2C24funciEi |
| int N::func(int)     | _ZN1N4funcEi     |

说明：所有符号以“_Z”开头，如果名字在命名空间或者类里面，后面加"N",然后接的是名字的长度，再是名字，以“E”结尾，最后的话，对于int就是i,double是d.

## 3.4弱符号和强符号

在c++中，编译器默认函数和初始化了的全局变量是强符号，未初始化的全局变量是弱符号，也可以用 __attribute __ ((weak))指示弱符号。

强，弱符号定义的时候都算定义，强符号只能一次定义，若符号可以多次定义，强符号能覆盖弱符号的定义，只有弱符号的时候，选择一个占用空间最大的作为它的定义。

## 3.5弱引用和强引用

引用一个符号，在链接的时候，找不到改符号的定义，链接器报错，这个叫做强引用（如申明一个函数，extern一个变量）；同样，如果编译器不报错，这个叫做弱引用（如用__ attribute__((weakref))修饰的），这个可以用在库的链接上和程序可以定制一些扩展功能的模块



# 第四章

## 4.1目标文件怎么合并为可执行文件

采用的是相似段合并，把相同性质的段合并到一起，比如将所有输入文件的".text"合并到输出文件的".text"段里

链接的过程：

第一步 空间与地址分配：先将所有的输入目标文件融合成一个文件，符号表中的所有符号定义和符号引用统一到一个全局符号表中

第二步 符号解析与重定位：读取输入文件中段的数据，重定位信息，并且进行符号解析与重定位。调整代码中的地址。

## 4.2在目标文件中怎么使用外部符号的

对于变量：将地址写成“0x00 00 00 00”

对于函数：将函数地址写成“0xFF FF FF FC（-4）”

## 4.3重定位表和符号表

重定位表(每个段都可以有自己的重定位表，.rel.text,.rel.data)中暗含了该目标文件中有哪些地方需要重定位，并且可以得到相应的符号，之后链接的时候到其他的目标文件找到相应的符号(全局符号表)得到其相对地址，重定位后就可以链接起来了。

## 4.4COMMON段的作用

为了处理一个弱符号定义在多个目标文件中，但是类型不一样，所以编译器不知道应该分配多大的空间，所以把这些弱符号放在COMMON段中(如未初始化的全局变量)

## 4.5重复代码消除

使用模板的过程很容易产生重复代码，解决的办法：将每个模板的实例代码都单独放在一个段中，每个段只包含一个模板实例

## 4.6全局对象的构造与析构

c++的全局对象的构造在main之前被执行(位于.init段)，析构函数在main之后被执行(位于.fini段)

# 第五章



# 第六章

## 6.1进程执行过程中三个概念

可执行文件，进程虚拟空间（这个由计算机硬件决定，即cpu的位数）和物理内存

在计算中存在两个东西保存着他们之间的映射：

虚拟内存区域（VMA）：它为进程的可执行文件中的每个段都分别设置了 一个VMA，然后它保存的信息是进程虚拟空间的地址映射到可执行文件中偏移

MMU：保存了进程的虚拟内存空间到物理内存的映射

ELF文件中的程序头表：保存了ELF文件section到进程虚拟内存空间segment的映射

正常情况下，操作系统访问数据，先得到了数据的进程虚拟地址，通过MMU得到物理地址，就可以访问数据

但是有可能例外，即得到进程虚拟地址之后，发现在MMU中并没有对应的物理地址，然后就出现页错误，之后通过查询对应的VMA得到该页在可执行文件中的位置，并且在物理内存中分配一个物理页面，加载进来后，在MMU中建立进程虚拟地址和物理页的映射关系。

综上，进程的虚拟空间处于在一个核心的位置。

> 可执行文件和进程虚拟空间之间不一定是原封不动的映射过来，为了节省空间会将，相同读写权限的段(section)放在一块(segment)。                     

## 6.2 section和segment

> 它们两是从不同角度划分同一个ELF文件的。在链接的时候，是以section的角度来看ELF文件的；在执行的时候，是以segment的角度来看ELF文件的。当我们在谈ELF转载时，段专门指segment，而在其他情况下，段是指section

> 类似于ELF有文件头保存section的信息，ELF文件有个专门的数据结构保存Segment信息，叫程序头表。对于ELF目标文件它并没有程序头表，因为它不需要加载，ELF可执行文件和共享库文件都有。

## 6.3 堆的最大申请数量

linux下虚拟空间分给进程本身的是3GB，实际上能够分配大概是2.9GB。基本和这个值差不多

## 6.4linux判断可执行文件的方式

首先它检查文件的前128个字节。因为linux支持的可执行文件不只ELF一种，还有a.out,Java程序和以”#！“开始的脚本程序，当然这个也是可以扩展的。每种可执行文件的开头几个字节比较特殊，特别是前四个字节，被称为魔数，如ELF的前四个字节为0x7F,'e','l','f',；java:'c','a','f','e'；而对应于shell脚本或perl，python解释型语言的脚本，它们的第一行分别为："#!/bin/sh","#!/usr/bin/perl","#!/usr/bin/python"

# 第七章

## 7.1动态链接出现的目的

> 解决静态链接的内存浪费，因为在静态链接中，两个不同程序用了相同的库，它会分别建立这个库的副本，而不会共用这个库

>  名称差异：
>
> linux:ELF动态链接文件被称为动态共享对象（DSO,Dynamic Shared Objects）,简称共享对象（so）
>
> window:动态链接文件称为动态链接库（Dynamic Linking Library,dll）

## 7.2 编译一个共享对象文件

gcc -fPIC  -shared  -o Lib.so  Lib.c

使用：gcc -o  Program1 Program1.c  ./Lib.so

## 7.3 链接过程中，静态编译和动态编译的差异

> 一个目标文件引用了其他文件的函数，若是静态链接，它就会按照静态链接的规则进行函数的重定位；而若是动态链接，那么链接器会将这个函数符号标记为一个动态链接的符号，这个时候不对其重定位，而在装载的时候重定位（当然怎么确定这个函数是一个静态符号还是动态符号，这些信息保存在.so文件中）

# 第八章

## 8.1动态链接器查找共享对象的顺序

> a.有环境变量LD_LIBRARY_PATH指定的路径（这个路径相当于gcc -L指定的路径（-l指定的是共享库名，如pthread(-lpthread同libpthread.so.2.1.4)））--》由文件/etc/profile中的LD_LIBRARY_PATH控制
>
> b.有路劲缓存文件/etc/ld.so.cache（可用ldconfig更新这个文件）--》由文件/etc/ld.so.conf文件控制
>
> c.默认的共享库目录，先/usr/lib，再/lib（/usr/local/lib这个目录不会遍历，需要后面指定）

## 8.2 创建一个共享库

> gcc -shared -fPIC -Wl,-soname,libLib.so.1 -o libLib.so.1.0.0 Lib.c

## 8.3 共享库的安装

> 最简单的办法就是讲共享库复制到某个标准的共享库目录，如/lib,/usr/lib等，然后运行ldconfig
>
> 或者首先利用ldconfig创建SO_NAME
>
> ldconfig -n shared_library_directory
>
> 然后在编译程序的时候指定共享库的位置，即 -L加共享库搜索路径和-l 加共享库名

# 第十章

